package jasbro.util;

import java.awt.Component;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;
import java.util.Map;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

import jasbro.game.character.CharacterBase;
import jasbro.game.character.CharacterType;
import jasbro.game.character.Gender;
import jasbro.game.character.attributes.BaseAttributeTypes;
import jasbro.game.character.specialization.SpecializationType;
import jasbro.game.character.traits.Trait;
import jasbro.gui.GuiUtil;
import jasbro.texts.TextUtil;

/**
 * 
 * @author Azrael
 */
public class CharacterDataEditorPanel extends javax.swing.JPanel implements PropertyChangeListener {
	private CharacterBase character;
	
	private int pointsToSpend = 0;
	private boolean noCheckFlag = false;
	
	private Map<BaseAttributeTypes, JSpinner> attributeSpinnerMap = new HashMap<BaseAttributeTypes, JSpinner>();
	private Map<Trait, JCheckBox> traitCheckboxMap = new HashMap<Trait, JCheckBox>();
	
	private javax.swing.JLabel availablePointsLabel;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JLabel jLabel2;
	private javax.swing.JTextField nameField;
	private JLabel lblNewLabel;
	private JComboBox<Gender> genderSelection;
	private JLabel lblType;
	private JComboBox<CharacterType> typeSelection;
	private JComboBox<SpecializationType> initialSpecializationSelection;
	private JTabbedPane tabbedPane;
	private JPanel characterDataPanel;
	private JPanel traitPanel;
	private JTextArea traitDescriptionField;
	private JTextArea descriptionField;
	
	/**
	 * Creates new form AttributeEditor
	 */
	public CharacterDataEditorPanel() {
		initComponents();
		addAttributeComponents();
		addTraitComponents();
	}
	
	public void nameChanged() {
		if (!noCheckFlag) {
			try {
				character.setName(nameField.getText());
				setCharacterChanged();
			} catch (Exception e) {
			}
			repaint();
		}
	}
	
	private void descriptionChanged() {
		if (!noCheckFlag) {
			try {
				character.setDescription(descriptionField.getText());
				setCharacterChanged();
			} catch (Exception e) {
			}
			repaint();
		}
	}
	
	public void setCharacter(CharacterBase character) {
		this.character = character;
		noCheckFlag = true;
		
		this.pointsToSpend = 0;
		availablePointsLabel.setText("0");
		nameField.setText(character.getName());
		for (BaseAttributeTypes attribute : BaseAttributeTypes.values()) {
			if (attribute != BaseAttributeTypes.COMMAND) {
				JSpinner spinner = attributeSpinnerMap.get(attribute);
				spinner.setValue(character.getAttribute(attribute));
			}
		}
		genderSelection.setSelectedItem(character.getGender());
		typeSelection.setSelectedItem(character.getType());
		
		for (Trait trait : Trait.getBasicTraits()) {
			JCheckBox checkBox = traitCheckboxMap.get(trait);
			checkBox.setSelected(character.getTraits().contains(trait));
		}
		
		noCheckFlag = false;
		
		descriptionField.setText(character.getDescription());
		repaint();
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private synchronized void initComponents() {
		noCheckFlag = true;
		setLayout(new java.awt.GridLayout(1, 1));
		
		tabbedPane = new JTabbedPane(JTabbedPane.TOP);
		add(tabbedPane);
		
		JScrollPane scrollPane = new JScrollPane(); 
		tabbedPane.addTab("Attributes", null, scrollPane, null);
		characterDataPanel = new JPanel();
		scrollPane.setViewportView(characterDataPanel);
		
		characterDataPanel.setLayout(new java.awt.GridLayout(0, 2));
		
		jLabel2 = new javax.swing.JLabel();
		characterDataPanel.add(jLabel2);
		jLabel2.setText("Name");
		
		nameField = new javax.swing.JTextField();
		characterDataPanel.add(nameField);
		
		lblNewLabel = new JLabel("Gender");
		characterDataPanel.add(lblNewLabel);
		
		genderSelection = new JComboBox<Gender>();
		characterDataPanel.add(genderSelection);
		
		lblType = new JLabel("Type");
		characterDataPanel.add(lblType);
		
		typeSelection = new JComboBox<CharacterType>();
		characterDataPanel.add(typeSelection);
		typeSelection.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if (!noCheckFlag) {
					character.setType((CharacterType) typeSelection.getSelectedItem());
					setCharacterChanged();
				}
			}
		});
		
		typeSelection.setRenderer(new DefaultListCellRenderer() {
			@SuppressWarnings("rawtypes")
			public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean hasFocus) {
				JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, hasFocus);
				CharacterType type = (CharacterType) value;
				if (type == null) {
					label.setText(TextUtil.t("ui.trainerOrSlave"));
				} else if (type == CharacterType.SLAVE) {
					label.setText(TextUtil.t("ui.slaveonly"));
				}
				else if (type == CharacterType.TRAINER) {
					label.setText(TextUtil.t("ui.traineronly"));
				} else {
					label.setText(type.getText());
				}
				return label;
			}
		});
		
		typeSelection.addItem(null);
		for (CharacterType type : CharacterType.values()) {
			typeSelection.addItem(type);
		}
		
		lblType = new JLabel("Initial specialization");
		characterDataPanel.add(lblType);
		
		initialSpecializationSelection = new JComboBox<SpecializationType>();
		characterDataPanel.add(initialSpecializationSelection);
		initialSpecializationSelection.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if (!noCheckFlag) {
					character.setInitialSpecialization((SpecializationType) initialSpecializationSelection.getSelectedItem());
					setCharacterChanged();
				}
			}
		});
		
		initialSpecializationSelection.addItem(null);
		for (SpecializationType type : SpecializationType.values()) {
			if (type != SpecializationType.SLAVE && type != SpecializationType.TRAINER && type != SpecializationType.SEX) {
				initialSpecializationSelection.addItem(type);
			}
		}
		
		jLabel1 = new javax.swing.JLabel();
		characterDataPanel.add(jLabel1);
		
		jLabel1.setText("Available Points");
		availablePointsLabel = new javax.swing.JLabel();
		characterDataPanel.add(availablePointsLabel);
		
		availablePointsLabel.setText("0");
		
		genderSelection.addItem(Gender.FEMALE);
		genderSelection.addItem(Gender.MALE);
		genderSelection.addItem(Gender.FUTA);
		genderSelection.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if (!noCheckFlag) {
					character.setGender((Gender) genderSelection.getSelectedItem());
					setCharacterChanged();
				}
			}
		});
		
		//init traits, do rest later
		traitPanel = new JPanel();
		traitPanel.setLayout(new GridLayout(0, 2));
		tabbedPane.addTab("Traits", null, traitPanel, null);
		
		//init description
		scrollPane = new JScrollPane(); 
		tabbedPane.addTab("Description Author", null, scrollPane, null);
		
		descriptionField = new JTextArea();
		descriptionField.setLineWrap(true);
		descriptionField.setWrapStyleWord(true);
		descriptionField.getDocument().addDocumentListener(new DocumentListener() {
			
			public void insertUpdate(DocumentEvent e) {
				descriptionChanged();
			}
			
			public void removeUpdate(DocumentEvent e) {
				descriptionChanged();
			}
			
			public void changedUpdate(DocumentEvent e) {
				descriptionChanged();
			}
		});
		scrollPane.setViewportView(descriptionField);
		
		noCheckFlag = false;
	}
	
	public void propertyChange(PropertyChangeEvent evt) {
		if (!noCheckFlag) {
			Integer oldInt = (Integer) evt.getOldValue();
			Integer newInt = (Integer) evt.getNewValue();
			JSpinner spinner = (JSpinner) ((JComponent) evt.getSource()).getParent().getParent();
			
			if (newInt < oldInt) {
				pointsToSpend++;
			} else {
				if (pointsToSpend <= 0) {
					noCheckFlag = true;
					spinner.setValue(oldInt);
					noCheckFlag = false;
				} else {
					pointsToSpend--;
					
					if (pointsToSpend == 0) {
						for (BaseAttributeTypes attribute : BaseAttributeTypes.values()) {
							spinner = attributeSpinnerMap.get(attribute);
							if (spinner != null) {
								character.setAttribute(attribute, (Integer) spinner.getValue());
							}
						}
						setCharacterChanged();
					}
				}
			}
			availablePointsLabel.setText(pointsToSpend + "");
		}
		repaint();
	}
	
	private void addAttributeComponents() {
		nameField.getDocument().addDocumentListener(new DocumentListener() {
			
			public void insertUpdate(DocumentEvent e) {
				nameChanged();
			}
			
			public void removeUpdate(DocumentEvent e) {
				nameChanged();
			}
			
			public void changedUpdate(DocumentEvent e) {
				nameChanged();
			}
		});
		
		for (BaseAttributeTypes attribute : BaseAttributeTypes.values()) {
			if (attribute != BaseAttributeTypes.COMMAND) {	// add command later
															// replacing
															// obedience for
															// trainers
				SpinnerModel spinnerModel = new SpinnerNumberModel(1, 1, 30, 1);
				if (attribute != BaseAttributeTypes.OBEDIENCE) {
					characterDataPanel.add(new JLabel(attribute.getText()));
				} else {
					characterDataPanel.add(new JLabel("Obedience / Command"));
				}
				JSpinner spinner = new JSpinner(spinnerModel);
				
				JSpinner.DefaultEditor editor = (JSpinner.DefaultEditor) spinner.getEditor();
				editor.getTextField().addPropertyChangeListener("value", this);
				
				attributeSpinnerMap.put(attribute, spinner);
				characterDataPanel.add(spinner);
			}
		}
	}
	
	public void addTraitComponents() {
		JPanel checkboxPanel = new JPanel();
		checkboxPanel.setLayout(new GridLayout(0, 1));
		JScrollPane scrollpane = new JScrollPane();
		scrollpane.setViewportView(checkboxPanel);
		traitPanel.add(scrollpane);
		
		ActionListener al = new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if (!noCheckFlag) {
					Trait trait = Trait.valueOf(e.getActionCommand());
					JCheckBox checkBox = (JCheckBox) e.getSource();
					if (checkBox.isSelected()) {
						character.addTrait(trait);
					}
					else {
						character.removeTrait(trait);
					}
					character.setChanged(true);
				}
			}
		};
		
		MouseListener ml = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				JCheckBox checkBox = (JCheckBox) e.getSource();
				Trait trait = Trait.valueOf(checkBox.getActionCommand());
				traitDescriptionField.setText(trait.getText() + "\n" + trait.getDescription());
			}
		};
		
		for (Trait trait : Trait.getBasicTraits()) {
			JCheckBox checkBox = new JCheckBox(trait.getText());
			checkBox.setToolTipText(trait.getDescription());
			checkBox.setActionCommand(trait.toString());
			checkBox.addActionListener(al);
			checkBox.addMouseListener(ml);
			traitCheckboxMap.put(trait, checkBox);
			checkboxPanel.add(checkBox);
		}
		
		traitDescriptionField = GuiUtil.getDefaultTextarea();
		traitPanel.add(traitDescriptionField);
		
		
	}
	
	private void setCharacterChanged() {
		character.setChanged(true);
	}
	
	public JPanel getCharacterDataPanel() {
		return characterDataPanel;
	}
}